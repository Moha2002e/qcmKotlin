[
  {
    "id": 1,
    "question": "Concernant Intent, lesquelles sont vraies ?",
    "options": [
      "Un Intent explicite cible une classe précise",
      "Un Intent implicite nécessite toujours un ComponentName",
      "Les Intent implicites utilisent les IntentFilter",
      "Un Intent ne peut pas transporter d’objets complexes",
      "Un Intent peut être utilisé pour démarrer un service"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "Un Intent explicite cible bien une classe (A). Les Intent implicites reposent sur des IntentFilters pour trouver le composant adéquat (C). Depuis Android, il est courant d'utiliser des Intents pour démarrer des services (E), bien que startService soit moins utilisé au profit de JobScheduler/WorkManager, c'est techniquement vrai."
  },
  {
    "id": 2,
    "question": "Quelle(s) affirmation(s) sur PendingIntent sont correctes ?",
    "options": [
      "Il permet à une application externe d’exécuter une action dans votre contexte",
      "Il est toujours lié à une Activity",
      "Il est requis pour les notifications",
      "Il remplace un Intent",
      "Il peut encapsuler un Broadcast"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "Le PendingIntent est un jeton donné à une application étrangère (comme le NotificationManager ou l'AlarmManager) lui permettant d'exécuter une action avec les permissions de votre application (A). Il est indispensable pour rendre une notification cliquable (C). Il peut encapsuler un Intent de démarrage d'Activity, de Service ou d'émission de Broadcast (E)."
  },
  {
    "id": 4,
    "question": "Concernant le cycle de vie d’une Activity",
    "options": [
      "onCreate() est appelé une seule fois par instance",
      "onPause() garantit que l’activité est détruite",
      "onStop() signifie que l’UI n’est plus visible",
      "onRestart() est appelé après onCreate()",
      "onDestroy() peut ne jamais être appelé"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "onCreate est le point d'entrée unique (A). onStop est appelé quand l'activité n'est plus visible par l'utilisateur (C). Le système peut tuer le processus sans appeler onDestroy en cas de besoin mémoire urgent, donc onDestroy n'est pas garanti (E)."
  },
  {
    "id": 5,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les constantes Intent.ACTION_* en Android ?",
    "options": [
      "Elles représentent des actions standard reconnues par le système Android",
      "Elles sont principalement utilisées avec des Intents implicites",
      "Intent.ACTION_* permet de cibler directement une Activity précise",
      "Elles peuvent être associées à des IntentFilter dans le manifeste",
      "Elles remplacent l’utilisation des ComponentName"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "Ce sont des chaînes standard (A) comme ACTION_VIEW ou ACTION_SEND, utilisées pour des Intents implicites (B) afin que n'importe quelle app compatible (déclarant ce filtre dans son manifeste, D) puisse y répondre."
  },
  {
    "id": 6,
    "question": "À propos des Fragment",
    "options": [
      "Un fragment doit être attaché à une activité",
      "Un fragment possède son propre Context",
      "Un fragment a un cycle de vie distinct",
      "Les fragments sont dépréciés",
      "Un fragment peut survivre à une rotation"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "Un Fragment vit nécessairement au sein d'une Activity (A) et possède un cycle de vie complexe lié mais distinct de celle-ci (C). Avec setRetainInstance(true) (bien que déprécié au profit des ViewModels), ou simplement via le mécanisme de restauration d'état, l'instance du fragment peut être conservée lors d'une changement de configuration (E)."
  },
  {
    "id": 7,
    "question": "Quelle méthode correspond à l’initialisation de la vue d’un fragment ?",
    "options": [
      "onAttach()",
      "onCreateView()",
      "onCreate()",
      "onViewCreated()",
      "onStart()"
    ],
    "correctAnswers": [
      1
    ],
    "explanation": "onCreateView() est la méthode où vous devez inflater le layout XML et retourner la Vue racine du fragment."
  },
  {
    "id": 8,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les expressions lambda en Kotlin ?",
    "options": [
      "Une lambda est une fonction anonyme",
      "Une lambda peut être passée comme paramètre à une fonction",
      "Une lambda ne peut pas capturer de variables externes",
      "Le type d’une lambda peut être inféré par le compilateur",
      "Une lambda ne peut pas retourner de valeur"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "Une lambda est bien une fonction sans nom (A), très souvent passée en paramètre (B). Kotlin infère son type (D). Contrairement à ce que dit C, elle peut capturer des variables (closure) et elle retourne la valeur de sa dernière expression (donc E est faux)."
  },
  {
    "id": 9,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les fonctions d’ordre supérieur en Kotlin ?",
    "options": [
      "Une fonction d’ordre supérieur peut prendre une ou plusieurs fonctions en paramètre",
      "Une fonction d’ordre supérieur peut retourner une fonction",
      "Une fonction d’ordre supérieur doit obligatoirement être inline",
      "Les fonctions d’ordre supérieur sont largement utilisées avec les lambdas",
      "Une fonction d’ordre supérieur ne peut pas être stockée dans une variable"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "C'est la définition même : prend des fonctions en paramètres ou en retourne (A, B). Elles sont conçues pour être utilisées avec des lambdas (D). Elles ne sont pas obligatoirement inline, bien que cela soit recommandé pour les performances."
  },
  {
    "id": 10,
    "question": "À propos de lateinit",
    "options": [
      "Uniquement pour les types non-null",
      "Ne fonctionne pas avec les types primitifs",
      "Peut être utilisé avec val",
      "Provoque une exception si non initialisé",
      "Compatible avec lazy"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "lateinit s'applique aux variables mutables (var) non-nulles (A). Elle ne supporte pas les types primitifs comme Int ou Boolean (B) car elle se base sur null en interne. Accéder à une propriété lateinit non initialisée lève une UninitializedPropertyAccessException (D)."
  },
  {
    "id": 11,
    "question": "Différence entre lazy et lateinit",
    "options": [
      "lazy est thread-safe par défaut",
      "lazy est uniquement pour val",
      "lateinit ne supporte pas les primitives",
      "lateinit est évalué à l’accès",
      "lazy peut être réassigné"
    ],
    "correctAnswers": [
      0,
      1,
      2
    ],
    "explanation": "Lazy est une délégation pour les constantes (val) (B) qui initialise la valeur au premier accès de manière thread-safe (A). Lateinit est pour les variables (var) et ne marche pas, entre autres, avec les types primitifs (C)."
  },
  {
    "id": 12,
    "question": "À propos des coroutines",
    "options": [
      "Une coroutine n’est pas un thread",
      "Une coroutine peut être suspendue",
      "Une coroutine bloque toujours le thread",
      "suspend n’indique pas l’asynchronisme",
      "Une coroutine survit à la mort du process"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "Une coroutine est un 'lightweight thread' géré par l'utilisateur, pas par l'OS (A). Elle peut être suspendue sans bloquer le thread sous-jacent (B). Le mot-clé suspend indique seulement qu'une fonction peut suspendre l'exécution, pas nécessairement qu'elle s'exécute sur un autre thread (D)."
  },
  {
    "id": 13,
    "question": "Que fait exactement suspend ?",
    "options": [
      "Rend la fonction asynchrone",
      "Crée un thread",
      "Permet la suspension sans bloquer",
      "Peut appeler d’autres fonctions suspendues",
      "Garantit un contexte IO"
    ],
    "correctAnswers": [
      2,
      3
    ],
    "explanation": "Le mot-clé suspend marque une fonction qui peut mettre en pause son exécution sans bloquer le thread courant (C). Seules les fonctions suspendues ou les coroutines peuvent appeler d'autres fonctions suspendues (D)."
  },
  {
    "id": 14,
    "question": "Concernant runBlocking",
    "options": [
      "Bloque le thread courant",
      "À utiliser en production Android",
      "Utile pour les tests",
      "Remplace launch",
      "Fonctionne uniquement sur Main thread"
    ],
    "correctAnswers": [
      0,
      2
    ],
    "explanation": "runBlocking démarre une coroutine et bloque le thread courant jusqu'à sa fin (A). C'est à éviter dans le code de production (pour ne pas figer l'UI), mais c'est très utile pour les tests unitaires ou les scripts (C)."
  },
  {
    "id": 15,
    "question": "Quelle est la différence entre launch et async ?",
    "options": [
      "launch retourne une valeur",
      "async retourne un Deferred",
      "async nécessite await()",
      "launch bloque",
      "async ne peut pas être annulé"
    ],
    "correctAnswers": [
      1,
      2
    ],
    "explanation": "Async est conçu pour calculer une valeur de manière asynchrone : il retourne un Deferred<T> (B) sur lequel on doit appeler await() pour récupérer le résultat (C). Launch retourne un Job et ne produit pas de résultat."
  },
  {
    "id": 16,
    "question": "Concernant Dispatcher.Main",
    "options": [
      "Exécute sur le thread UI",
      "Peut être utilisé pour IO intensif",
      "Requiert Dispatchers.Main.immediate pour éviter un post",
      "Est toujours disponible",
      "Nécessite Android"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "Dispatcher.Main utilise le thread principal (UI) d'Android (A). Il n'est disponible que sur les plateformes ayant une UI (Android, JavaFx...), donc E est vrai. Main.immediate est une optimisation pour exécuter la coroutine tout de suite si on est déjà sur le bon thread, évitant un dispatch inutile (C)."
  },
  {
    "id": 17,
    "question": "À propos de l’annulation (cancel)",
    "options": [
      "Elle est coopérative",
      "Elle stoppe immédiatement la coroutine",
      "Les suspending functions la respectent",
      "Elle tue le thread",
      "Elle propage aux enfants"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "L'annulation en Kotlin est coopérative (A) : le code de la coroutine doit vérifier s'il est actif. Les fonctions de suspension standard vérifient l'annulation (C). L'annulation d'un parent entraîne celle de tous ses enfants (E)."
  },
  {
    "id": 18,
    "question": "Quelle exception est levée lors d’une annulation ?",
    "options": [
      "TimeoutException",
      "IllegalStateException",
      "CancellationException",
      "IOException",
      "RuntimeException"
    ],
    "correctAnswers": [
      2
    ],
    "explanation": "L'annulation d'une coroutine se fait en jetant une CancellationException. C'est une exception spéciale qui est ignorée par les mécanismes de crash standard mais qui arrête la coroutine."
  },
  {
    "id": 19,
    "question": "Quelle est la portée correcte pour une coroutine liée à un Fragment ?",
    "options": [
      "GlobalScope",
      "MainScope",
      "viewLifecycleOwner.lifecycleScope",
      "activityScope",
      "applicationScope"
    ],
    "correctAnswers": [
      2
    ],
    "explanation": "Dans un Fragment, il faut utiliser viewLifecycleOwner.lifecycleScope pour que les coroutines s'arrêtent lorsque la VUE du fragment est détruite (et pas seulement l'instance du fragment), évitant ainsi des leaks ou des crashs."
  },
  {
    "id": 20,
    "question": "Concernant RecyclerView",
    "options": [
      "Il recycle les ViewHolder",
      "Il est plus performant que ListView",
      "Il impose un layout vertical",
      "Il nécessite un Adapter",
      "Il gère automatiquement les clics"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "RecyclerView est conçu pour afficher de grandes listes efficacement en recyclant les vues via le pattern ViewHolder (A, B). Il a absolument besoin d'un Adapter pour faire le lien avec les données (D). Il n'impose pas de layout (LayoutManager flexible) et ne gère pas les clics nativement (il faut les gérer dans le ViewHolder)."
  },
  {
    "id": 21,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les fonctions de portée (let, run, apply, also, with) en Kotlin ?",
    "options": [
      "Les fonctions de portée permettent d’exécuter un bloc de code dans le contexte d’un objet",
      "Elles diffèrent par la valeur de retour et la manière d’accéder au receiver (this ou it)",
      "Toutes les fonctions de portée retournent toujours l’objet receiver",
      "Elles améliorent la lisibilité et réduisent le code répétitif",
      "Les fonctions de portée remplacent les classes et les fonctions classiques"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "Ces fonctions créent un scope temporaire autour d'un objet (A). Elles se distinguent par le contexte (this vs it) et le retour (résultat du bloc vs objet lui-même) (B). Elles servent à rendre le code plus concis et fluide (D)."
  },
  {
    "id": 22,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les fonctions de portée Kotlin (let, run, with, apply, also) ?",
    "options": [
      "let et also utilisent it comme contexte d’accès à l’objet",
      "apply et also retournent l’objet receiver",
      "run et with retournent le résultat du dernier bloc exécuté",
      "with peut être appelé sur un objet nullable sans vérification préalable",
      "apply est particulièrement adapté à la configuration ou au pattern builder"
    ],
    "correctAnswers": [
      0,
      1,
      2,
      4
    ],
    "explanation": "Let/Also utilisent l'argument par défaut 'it' (A). Apply/Also retournent l'objet lui-même, idéal pour le chaînage (B). Run/With retournent le résultat de la lambda (C). Apply change le contexte en 'this' et retourne l'objet, parfait pour configurer un objet à sa création (E)."
  },
  {
    "id": 23,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les propriétés isActive, isCancelled et isCompleted d’une coroutine (Job) ?",
    "options": [
      "isActive est vrai tant que la coroutine s’exécute ou peut encore s’exécuter",
      "isCancelled devient vrai lorsqu’une annulation est demandée, même si la coroutine n’est pas encore terminée",
      "isCompleted devient vrai uniquement lorsque la coroutine a terminé son exécution (succès ou échec)",
      "isCancelled et isCompleted sont toujours vrais simultanément",
      "Une coroutine annulée est considérée comme complétée (isCompleted == true) une fois son exécution terminée"
    ],
    "correctAnswers": [
      0,
      1,
      2,
      4
    ],
    "explanation": "isActive est vrai au démarrage. isCancelled passe à vrai dès l'appel à cancel(), même si le code de nettoyage tourne encore (B). isCompleted est l'état final, atteint après succès, échec ou annulation complète (C, E)."
  },
  {
    "id": 24,
    "question": "Concernant ViewBinding",
    "options": [
      "Généré à la compilation",
      "Utilise la réflexion",
      "Supprime findViewById",
      "Est plus lent que DataBinding",
      "Respecte le type-safety"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "ViewBinding génère une classe Java/Kotlin pour chaque XML à la compilation (A), éliminant findViewById (C) et les casts risqués, garantissant ainsi le type-safety (E) et la null-safety."
  },
  {
    "id": 25,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant CoroutineContext, CoroutineDispatcher et CoroutineScope ?",
    "options": [
      "CoroutineContext est une collection d’éléments décrivant l’environnement d’exécution d’une coroutine",
      "CoroutineDispatcher détermine sur quel thread ou pool de threads la coroutine s’exécute",
      "CoroutineScope définit la durée de vie des coroutines qu’il lance",
      "CoroutineDispatcher est obligatoire pour lancer une coroutine",
      "Un CoroutineScope combine généralement un CoroutineContext et un Job"
    ],
    "correctAnswers": [
      0,
      1,
      2,
      4
    ],
    "explanation": "Le Contexte contient les éléments de config (A). Le Dispatcher gère les threads (B). Le Scope définit la portée/durée de vie (C) et contient un contexte (E)."
  },
  {
    "id": 26,
    "question": "Concernant Navigation Component",
    "options": [
      "Gère le back stack",
      "Remplace FragmentManager",
      "Utilise un NavGraph",
      "Fonctionne sans fragments",
      "Facilite SafeArgs"
    ],
    "correctAnswers": [
      0,
      1,
      2,
      4
    ],
    "explanation": "Navigation Component simplifie la navigation en gérant la pile retour (A) et les transactions de fragments (B) via un graphe XML (C). SafeArgs génère du code pour passer des arguments typés entre destinations (E)."
  },
  {
    "id": 27,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant une suspending function en Kotlin ?",
    "options": [
      "Une suspending function peut suspendre son exécution sans bloquer le thread",
      "Une suspending function ne peut être appelée que depuis une coroutine ou une autre suspending function",
      "Une suspending function crée automatiquement un nouveau thread",
      "Lorsqu’elle est suspendue, le thread peut exécuter d’autres tâches",
      "Une suspending function garantit une exécution parallèle"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "Une fonction suspend est une fonction qui peut faire pause (A) sans bloquer le thread (D), permettant à celui-ci de faire autre chose. Elle doit être appelée dans un contexte de suspension (B)."
  },
  {
    "id": 28,
    "question": "Quelle classe gère la navigation ?",
    "options": [
      "FragmentManager",
      "NavController",
      "NavHost",
      "Router",
      "ActivityManager"
    ],
    "correctAnswers": [
      1
    ],
    "explanation": "Le NavController est l'objet central qui orchestre l'échange de contenu dans le NavHost."
  },
  {
    "id": 29,
    "question": "Quelle est la responsabilité de NavHostFragment ?",
    "options": [
      "Gérer les intents",
      "Afficher les destinations",
      "Créer les fragments",
      "Sauvegarder l’état",
      "Gérer ViewBinding"
    ],
    "correctAnswers": [
      1,
      2
    ],
    "explanation": "Le NavHostFragment agit comme un conteneur qui affiche et échange les destinations (fragments) (B, C) en fonction de la navigation."
  },
  {
    "id": 30,
    "question": "Concernant Kotlin null-safety",
    "options": [
      "? rend nullable",
      "!! peut lever une exception",
      "?: est un opérateur Elvis",
      "let évite les NPE",
      "lateinit accepte null"
    ],
    "correctAnswers": [
      0,
      1,
      2,
      3
    ],
    "explanation": "'?' marque un type nullable (A). '!!' force le déballage et crash si null (B). '?:' fournit une valeur par défaut si null (C). '?.let {}' permet d'exécuter du code seulement si l'objet n'est pas null (D)."
  },
  {
    "id": 31,
    "question": "Quel(s) scope(s) Kotlin existent ?",
    "options": [
      "let",
      "apply",
      "run",
      "with",
      "also"
    ],
    "correctAnswers": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Tous (let, run, with, apply, also) sont des fonctions de portée (scope functions) standard en Kotlin."
  },
  {
    "id": 32,
    "question": "Différence entre apply et also",
    "options": [
      "apply retourne le receiver",
      "also retourne le receiver",
      "apply utilise this",
      "also utilise it",
      "also modifie le receiver"
    ],
    "correctAnswers": [
      0,
      1,
      2,
      3
    ],
    "explanation": "Les deux retournent l'objet (A, B). Mais 'apply' expose l'objet via 'this' (C) (idéal pour initialisation), tandis que 'also' l'expose via 'it' (D) (idéal pour effets de bord comme le logging)."
  },
  {
    "id": 33,
    "question": "Concernant sealed class",
    "options": [
      "Restreint l’héritage",
      "Peut être étendue partout",
      "Utile pour when exhaustif",
      "Remplacée par enum",
      "Permet des états complexes"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "Une sealed class restreint l'héritage à un ensemble connu à la compilation (A), ce qui permet des instructions 'when' exhaustives sans branche 'else' (C). Contrairement aux enums, elles peuvent avoir des instances avec des états différents (E)."
  },
  {
    "id": 34,
    "question": "À propos de when",
    "options": [
      "Peut être exhaustif",
      "Remplace if uniquement",
      "Fonctionne avec sealed class",
      "Est une expression",
      "Ne retourne rien"
    ],
    "correctAnswers": [
      0,
      2,
      3
    ],
    "explanation": "'when' est une expression qui peut retourner une valeur (D). Il est particulièrement puissant avec les sealed classes où le compilateur vérifie l'exhaustivité (A, C)."
  },
  {
    "id": 36,
    "question": "Quelle affirmation est vraie sur inline ?",
    "options": [
      "Réduit l’overhead lambda",
      "Augmente la taille du bytecode",
      "Utilisable avec reified",
      "Obligatoire",
      "Désactivée sur Android"
    ],
    "correctAnswers": [
      0,
      1,
      2
    ],
    "explanation": "L'inlining copie le corps de la fonction au lieu de l'appeler, ce qui évite la création d'objets pour les lambdas (A) mais augmente la taille du code compiler (B). C'est nécessaire pour supporter les types 'reified' (C)."
  },
  {
    "id": 38,
    "question": "Concernant les data class",
    "options": [
      "Génèrent equals/hashCode",
      "Génèrent copy()",
      "Peuvent être abstract",
      "Peuvent être sealed",
      "Améliorent l’immuabilité"
    ],
    "correctAnswers": [
      0,
      1,
      4
    ],
    "explanation": "Les data classes sont faites pour stocker des données. Le compilateur génère automatiquement equals, hashCode, toString et copy (A, B). Elles encouragent l'utilisation de propriétés 'val', favorisant l'immuabilité (E)."
  },
  {
    "id": 40,
    "question": "Quelle(s) bonne(s) pratique(s) Android/Kotlin ?",
    "options": [
      "Éviter GlobalScope",
      "Utiliser lifecycleScope",
      "Bloquer le thread Main",
      "Préférer immutabilité",
      "Limiter les context leaks"
    ],
    "correctAnswers": [
      0,
      1,
      3,
      4
    ],
    "explanation": "GlobalScope ne respecte pas le cycle de vie (A). LifecycleScope est plus sûr (B). L'immuabilité réduit les effets de bord (D). Les fuites de contexte (Memory Leaks) sont critiques en Android (E)."
  },
  {
    "id": 41,
    "question": "Concernant lifecycleScope",
    "options": [
      "Disponible uniquement dans les fragments",
      "Annule automatiquement les coroutines à la destruction",
      "Basé sur le LifecycleOwner",
      "Exécute toujours sur Dispatchers.IO",
      "Évite les memory leaks"
    ],
    "correctAnswers": [
      1,
      2,
      4
    ],
    "explanation": "Il est lié à tout LifecycleOwner (Activity, Fragment...) (C). Il annule automatiquement les tâches quand le cycle de vie est détruit (B), prévenant ainsi les fuites de mémoire (E)."
  },
  {
    "id": 42,
    "question": "Différence entre lifecycleScope et viewLifecycleOwner.lifecycleScope",
    "options": [
      "Ils sont identiques",
      "Le second est lié au cycle de vie de la vue",
      "Évite les crashes après onDestroyView()",
      "Le premier est déprécié",
      "Le second fonctionne dans une Activity"
    ],
    "correctAnswers": [
      1,
      2
    ],
    "explanation": "Dans un Fragment, l'instance du Fragment survit plus longtemps que sa Vue. viewLifecycleOwner suit la Vue (B). Utiliser le scope de la vue évite de tenter de mettre à jour une vue détruite (C)."
  },
  {
    "id": 43,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les suspending functions et le mécanisme de Continuation<T> en Kotlin ?",
    "options": [
      "Une suspending function est compilée avec un paramètre implicite de type Continuation<T>",
      "Continuation<T> représente la suite de l’exécution après un point de suspension",
      "Une suspending function crée systématiquement un nouveau thread",
      "Le compilateur transforme une suspending function en machine à états",
      "La suspension permet de libérer le thread sans consommer de ressources importantes"
    ],
    "correctAnswers": [
      0,
      1,
      3,
      4
    ],
    "explanation": "En interne, le compilateur transforme le code en CPS (Continuation Passing Style) (A, B) et génère une machine à états (D). Cela permet de suspendre l'exécution et de libérer le thread (E) sans en créer de nouveaux à chaque fois."
  },
  {
    "id": 44,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant l’internationalisation (i18n) et l’utilisation des fichiers de ressources dans Android ?",
    "options": [
      "Les chaînes traduites sont définies dans des fichiers strings.xml spécifiques par langue",
      "Android sélectionne automatiquement les ressources en fonction de la locale du système",
      "Les fichiers de ressources internationalisées doivent être chargés manuellement dans le code",
      "Il est possible de définir des variantes régionales (ex. fr-rBE, en-rUS)",
      "L’internationalisation empêche toute modification dynamique de la langue de l’application"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "Android utilise un système de qualificateurs de ressources (ex: values-fr) (A, D) et charge automatiquement la bonne ressource selon la configuration du device (B)."
  },
  {
    "id": 45,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant Configuration, l’accès via getConfiguration() et l’utilisation de Locale en Android ?",
    "options": [
      "getConfiguration() permet d’accéder à la configuration courante de l’appareil (langue, orientation, densité, etc.)",
      "La langue courante peut être obtenue à partir de Configuration.locale ou Configuration.locales selon la version d’Android",
      "Modifier un objet Locale met automatiquement à jour la langue de l’application",
      "À partir d’Android 7.0, plusieurs locales peuvent être définies via LocaleList",
      "Un changement de Configuration peut déclencher la recréation d’une Activity"
    ],
    "correctAnswers": [
      0,
      1,
      3,
      4
    ],
    "explanation": "L'objet Configuration reflète l'état actuel (A). Depuis Android 7 (Nougat), on supporte les listes de langues préférées (B, D). Un changement de config (rotation, langue) redémarre l'activité par défaut (E)."
  },
  {
    "id": 46,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant l’architecture Android et les rôles respectifs des Libraries, de la HAL (Hardware Abstraction Layer) et du hardware ?",
    "options": [
      "La HAL fournit une interface standardisée entre le framework Android et le matériel",
      "Les Libraries Android offrent des fonctionnalités de haut niveau accessibles aux applications",
      "Le hardware est directement manipulé par les applications Android",
      "La HAL permet d’isoler Android des spécificités matérielles des constructeurs",
      "Les Libraries remplacent la HAL pour l’accès aux composants matériels"
    ],
    "correctAnswers": [
      0,
      3
    ],
    "explanation": "La HAL (Hardware Abstraction Layer) est cruciale : elle définit une interface standard que les constructeurs de téléphones doivent implémenter pour que le Framework Android puisse parler au matériel (A, D) sans connaître les détails spécifiques des puces."
  },
  {
    "id": 47,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant la machine virtuelle Dalvik dans l’écosystème Android ?",
    "options": [
      "Dalvik est une machine virtuelle conçue spécifiquement pour les appareils mobiles Android",
      "Dalvik exécute des fichiers au format .dex (Dalvik Executable)",
      "Dalvik utilise exclusivement la compilation AOT (Ahead-Of-Time)",
      "Dalvik a été remplacée progressivement par ART à partir d’Android 5.0",
      "Dalvik fonctionne avec un modèle “une VM par application” afin d’isoler les apps"
    ],
    "correctAnswers": [
      0,
      1,
      3,
      4
    ],
    "explanation": "Dalvik était la VM d'origine d'Android (A), utilisant le format .dex (B) et le JIT (Just-In-Time). Elle a été remplacée par ART (Android Runtime) qui utilise l'AOT (Ahead-Of-Time) (D). Chaque app tourne dans son propre processus avec sa propre instance de VM (E)."
  },
  {
    "id": 48,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les densités d’écran (ldpi, mdpi, hdpi) et la gestion des ressources Android ?",
    "options": [
      "mdpi est considérée comme la densité de référence (baseline)",
      "Android sélectionne automatiquement les ressources graphiques adaptées à la densité de l’écran",
      "ldpi correspond à une densité plus élevée que hdpi",
      "Les ressources peuvent être placées dans des dossiers spécifiques comme drawable-ldpi, drawable-mdpi, drawable-hdpi",
      "Fournir une ressource uniquement en hdpi empêche son affichage sur un écran mdpi"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "mdpi (160dpi) est la base (1px = 1dp) (A). Android scale automatiquement les ressources (B). On fournit souvent différentes versions dans des dossiers qualifiés (D). ldpi est 'low' density, donc plus faible que hdpi (high)."
  },
  {
    "id": 49,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les Services Android et l’utilisation de startService / arrêt d’un service ?",
    "options": [
      "Un service démarré avec startService peut continuer à s’exécuter même si l’Activity appelante est détruite",
      "Un service démarré doit être arrêté explicitement via stopService ou stopSelf",
      "Un service démarre toujours sur un thread séparé",
      "Le système Android peut arrêter un service pour récupérer des ressources",
      "Un service démarré ne peut pas être redémarré après avoir été arrêté"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "Les Services tournent par défaut sur le Main Thread (donc C est faux). Une fois démarré (Started Service), il vit sa vie indépendamment de l'appelant (A) jusqu'à ce qu'il soit stoppé explicitement (B) ou tué par le système (D)."
  },
  {
    "id": 50,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les méthodes onCreate, onDestroy et onBind d’un Service Android ?",
    "options": [
      "onCreate est appelée une seule fois lors de la création du service",
      "onDestroy est appelée lorsque le service est définitivement arrêté",
      "onBind est appelée lorsqu’un composant se lie au service",
      "onBind est appelée pour un service démarré uniquement avec startService",
      "Un service lié utilise onBind pour exposer une interface de communication aux clients"
    ],
    "correctAnswers": [
      0,
      1,
      2,
      4
    ],
    "explanation": "onCreate initialisation unique (A). onBind est spécifique au Binding (liaison) entre composants (C, E) et retourne un IBinder. onDestroy pour le nettoyage final (B)."
  },
  {
    "id": 51,
    "question": "À propos de SavedStateHandle",
    "options": [
      "Persiste après process death",
      "Remplace ViewModel",
      "Fonctionne avec Navigation",
      "Sauvegarde automatiquement tout",
      "Accessible dans ViewModel"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "SavedStateHandle permet de sauvegarder de petites données qui survèvent à l'arrêt du processus par le système (A). Il est intégré aux ViewModels (E) et fonctionne bien avec les arguments de Navigation (C)."
  },
  {
    "id": 52,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les Fragments et les Activities en Android ?",
    "options": [
      "Une Activity représente un écran complet et constitue un point d’entrée de l’application",
      "Un Fragment est toujours hébergé par une Activity",
      "Un Fragment peut exister indépendamment d’une Activity",
      "Les Fragments permettent une UI plus modulaire et réutilisable",
      "Une Activity partage automatiquement son cycle de vie avec tous ses Fragments"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "L'Activity est le contenant principal (A). Les Fragments sont des composants d'UI modulaires (D) qui doivent vivre dans une Activity (B)."
  },
  {
    "id": 58,
    "question": "ConstraintLayout",
    "options": [
      "Réduit la hiérarchie",
      "Plus lent que LinearLayout",
      "Supporte les chaînes",
      "Oblige XML complexe",
      "Déprécié"
    ],
    "correctAnswers": [
      0,
      2
    ],
    "explanation": "ConstraintLayout permet de créer des layouts complexes à plat, réduisant l'imbrication des vues (A). Il offre des fonctionnalités avancées comme les chaînes (chains) de vues (C)."
  },
  {
    "id": 59,
    "question": "Concernant la navigation back",
    "options": [
      "NavController gère le back stack",
      "FragmentManager est obligatoire",
      "PopBackStack possible",
      "Le système ignore le graphe",
      "Back est automatique partout"
    ],
    "correctAnswers": [
      0,
      2
    ],
    "explanation": "Avec Navigation Component, le NavController gère la pile de retour (A). La fonction popBackStack() permet de revenir programmateriquement en arrière (C)."
  },
  {
    "id": 65,
    "question": "Concernant coroutineScope",
    "options": [
      "Attend toutes les coroutines enfants",
      "Lance des GlobalScope",
      "Propague les exceptions",
      "Bloque le thread",
      "Remplace supervisorScope"
    ],
    "correctAnswers": [
      0,
      2
    ],
    "explanation": "coroutineScope est une fonction de suspension qui crée un sous-scope. Elle attend que tous ses enfants soient finis avant de rendre la main (A). Si un enfant échoue, elle annule tous les autres et propage l'exception (C). (Contrairement à supervisorScope)."
  },
  {
    "id": 67,
    "question": "Concernant ExceptionHandler",
    "options": [
      "Intercepte les exceptions non catchées",
      "Remplace try/catch",
      "Appliqué au scope",
      "Fonctionne avec async",
      "Stoppe le thread"
    ],
    "correctAnswers": [
      0,
      2
    ],
    "explanation": "CoroutineExceptionHandler (CEH) est un élément de contexte (C) qui attrape les exceptions non gérées par ailleurs (A) dans les coroutines 'launch'. Il ne remplace pas try/catch pour la gestion locale."
  },
  {
    "id": 68,
    "question": "Kotlin Result<T>",
    "options": [
      "Encapsule succès/échec",
      "Remplace exceptions",
      "Immuable",
      "Toujours recommandé",
      "Bloque la stacktrace"
    ],
    "correctAnswers": [
      0,
      2
    ],
    "explanation": "La classe Result encapsule soit une valeur de succès, soit une erreur (Throwable) (A). Elle est une value class (immuable et performante) (C). Elle permet un style de programmation plus fonctionnel sans forcément remplacer toutes les exceptions."
  },
  {
    "id": 70,
    "question": "Concernant Context",
    "options": [
      "Activity est un Context",
      "ApplicationContext survit toujours",
      "Context peut causer des leaks",
      "Context = View",
      "Ne pas stocker Activity"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "Activity hérite de Context (A). Garder une référence statique à une Activity (Context) empêche le Garbage Collector de la nettoyer, causant un Memory Leak majeur (C, E)."
  },
  {
    "id": 73,
    "question": "Concernant les lambdas",
    "options": [
      "Fonctions anonymes",
      "Toujours inline",
      "Supportent capture",
      "Pas de retour",
      "Bloquantes"
    ],
    "correctAnswers": [
      0,
      2
    ],
    "explanation": "Les lambdas sont des fonctions anonymes (A). Elles peuvent capturer des variables de leur portée englobante (C)."
  },
  {
    "id": 74,
    "question": "Kotlin immutabilité",
    "options": [
      "val préféré",
      "var interdit",
      "Favorise thread-safety",
      "Inutile en Android",
      "Réduit bugs"
    ],
    "correctAnswers": [
      0,
      2,
      4
    ],
    "explanation": "En Kotlin, on préfère 'val' (read-only) par défaut (A). Les objets immuables sont intrinsèquement thread-safe (C) et réduisent les bugs liés aux changements d'état inattendus (E)."
  },
  {
    "id": 75,
    "question": "Considère le code Kotlin suivant :\nval a = 10 \nvar b = a \nval c: Number = a \nvar d: Int? = null \nLaquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) ?",
    "options": [
      "a est une constante et ne peut jamais être modifiée",
      "b peut être réassignée car son type est inféré comme Int",
      "c ne peut pas être réassignée car son type explicite est Number",
      "d ne peut accepter que null ou des Int",
      "Le typage explicite empêche toute inférence du compilateur"
    ],
    "correctAnswers": [
      1,
      3
    ],
    "explanation": "'val' déclare une variable en lecture seule (A). 'var' est mutable et 'b' est inféré comme Int (B). 'd' est un Int nullable, donc accepte Int ou null (D)."
  },
  {
    "id": 76,
    "question": "Considère les instructions Kotlin suivantes :\nfor (i in 1..5) print(i) \nfor (i in 0 until 5) print(i) \nfor (i in 10 downTo 0 step 2) print(i) \nQuelle(s) affirmation(s) est/sont correcte(s) ?",
    "options": [
      "L’opérateur .. inclut la borne supérieure",
      "until exclut la borne supérieure",
      "downTo permet une itération décroissante",
      "step modifie la valeur finale de la borne",
      "step définit l’incrément (ou décrément) entre deux valeurs successives"
    ],
    "correctAnswers": [
      0,
      1,
      2,
      4
    ],
    "explanation": "'..' crée un range inclusif (A). 'until' exclut la fin (B). 'downTo' inverse l'ordre (C). 'step' définit le pas d'itération (E)."
  },
  {
    "id": 77,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant les mots-clés open et final en Kotlin ?",
    "options": [
      "En Kotlin, les classes sont final par défaut",
      "Une classe marquée open peut être héritée",
      "Une fonction doit être open pour pouvoir être appelée",
      "Une fonction open peut être redéfinie (override) dans une sous-classe",
      "Le mot-clé final empêche l’héritage ou la redéfinition"
    ],
    "correctAnswers": [
      0,
      1,
      3,
      4
    ],
    "explanation": "Contrairement à Java, les classes Kotlin sont fermées (final) par défaut (A). Il faut le mot-clé 'open' pour permettre l'héritage (B) ou l'override de méthodes (D)."
  },
  {
    "id": 78,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant ViewBinding et findViewById ?",
    "options": [
      "ViewBinding fournit un accès type-safe aux vues",
      "ViewBinding élimine le besoin d’appeler findViewById",
      "findViewById est vérifié à la compilation",
      "ViewBinding réduit le risque de NullPointerException",
      "ViewBinding repose sur la réflexion à l’exécution"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "ViewBinding génère des références directes et typées aux vues (A), remplaçant findViewById (B). Comme il sait quelles vues sont présentes dans quelles configs (portrait/landscape), il gère mieux la nullabilité (D)."
  },
  {
    "id": 79,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant l’utilisation de startActivity dans une application Android ?",
    "options": [
      "startActivity permet de lancer une nouvelle Activity via un Intent",
      "Un Context valide est requis pour appeler startActivity",
      "startActivity permet de récupérer directement un résultat",
      "startActivity peut être utilisé avec un Intent explicite ou implicite",
      "startActivity gère automatiquement le cycle de vie de l’Activity appelante"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "startActivity lance une activité (A) via un Intent (D). C'est une méthode de la classe Context (B). Pour récupérer un résultat, il faudrait utiliser registerForActivityResult (anciennement startActivityForResult)."
  },
  {
    "id": 80,
    "question": "Laquelle (ou lesquelles) des affirmations suivantes est/sont correcte(s) concernant l’utilisation de putExtra et des méthodes getXXXExtra dans les Intent Android ?",
    "options": [
      "putExtra permet d’ajouter des données supplémentaires à un Intent",
      "getXXXExtra doit correspondre au type exact de la donnée stockée",
      "Un Intent ne peut contenir qu’un seul extra",
      "Les extras sont stockés sous forme de paires clé/valeur",
      "getXXXExtra lève systématiquement une exception si la clé n’existe pas"
    ],
    "correctAnswers": [
      0,
      1,
      3
    ],
    "explanation": "Les Extras sont un Bundle (clé-valeur) (D) attaché à l'Intent. On ajoute avec putExtra (A). Il faut récupérer avec la méthode typée correspondante (getIntExtra, getStringExtra...) (B)."
  }
]