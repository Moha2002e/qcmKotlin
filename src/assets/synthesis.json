[
    {
        "category": "Fondamentaux Android",
        "icon": "ðŸ“±",
        "points": [
            {
                "concept": "Activity vs Fragment",
                "details": "L'Activity est le point d'entrÃ©e et le contenant. Le Fragment est une portion d'UI rÃ©utilisable. Un Fragment vit DANS une Activity. Attention : le Fragment a son propre cycle de vie + celui de sa Vue (onDestroyView)."
            },
            {
                "concept": "Cycle de vie Activity",
                "details": "onCreate() (init unique) -> onStart() (visible) -> onResume() (interactif). Inverse : onPause() -> onStop() -> onDestroy()."
            },
            {
                "concept": "Intents",
                "details": "â€¢ Explicite : Cible une classe prÃ©cise (navigation interne).\nâ€¢ Implicite : DÃ©crit une action (ACTION_VIEW), le systÃ¨me trouve l'app (partage, web)."
            },
            {
                "concept": "Services",
                "details": "TÃ¢che de fond. Started (startService) vit indÃ©finiment jusqu'Ã  stopSelf(). Bound (bindService) vit tant qu'un client est connectÃ©."
            }
        ]
    },
    {
        "category": "Coroutines & Asynchrone",
        "icon": "âš¡",
        "points": [
            {
                "concept": "Mots-clÃ©s",
                "details": "â€¢ suspend : Fonction qui peut faire 'pause' sans bloquer le thread.\nâ€¢ launch : Tire et oublie (return Job).\nâ€¢ async : Calcul de rÃ©sultat (return Deferred, nÃ©cessite await())."
            },
            {
                "concept": "Dispatchers",
                "details": "â€¢ Main : UI (interdit de bloquer !).\nâ€¢ IO : Disque/RÃ©seau.\nâ€¢ Default : Calculs CPU lourds."
            },
            {
                "concept": "Scopes",
                "details": "â€¢ lifecycleScope : LiÃ© Ã  l'Activity/Fragment.\nâ€¢ viewModelScope : LiÃ© au ViewModel.\nâ€¢ GlobalScope : Ã€ Ã‰VITER (fuites mÃ©moires)."
            }
        ]
    },
    {
        "category": "Langage Kotlin",
        "icon": "ðŸ’Ž",
        "points": [
            {
                "concept": "Var vs Val",
                "details": "Toujours prÃ©fÃ©rer 'val' (immuable). 'var' est mutable."
            },
            {
                "concept": "Null Safety",
                "details": "Type? = nullable. ?. (safe call), !! (force crash si null), ?: (Elvis, valeur par dÃ©faut)."
            },
            {
                "concept": "Scope Functions",
                "details": "â€¢ let (it) -> rÃ©sultat lambda\nâ€¢ also (it) -> objet lui-mÃªme\nâ€¢ apply (this) -> objet lui-mÃªme (config)\nâ€¢ run (this) -> rÃ©sultat lambda"
            },
            {
                "concept": "Lazy vs Lateinit",
                "details": "â€¢ lazy : Pour 'val', calculÃ© au 1er accÃ¨s.\nâ€¢ lateinit : Pour 'var' non-nullable, initialisÃ© plus tard (promesse)."
            }
        ]
    },
    {
        "category": "Architecture & UI",
        "icon": "ðŸ—ï¸",
        "points": [
            {
                "concept": "ViewBinding",
                "details": "Remplace findViewById. GÃ©nÃ¨re une classe de liaison sÃ»re (null-safe, type-safe) pour chaque XML."
            },
            {
                "concept": "Navigation Component",
                "details": "Activity unique (Single Activity). NavController gÃ¨re le remplacement des Fragments et la pile retour (BackStack)."
            },
            {
                "concept": "RecyclerView",
                "details": "Obligatoire pour les listes. NÃ©cessite un Adapter (donnÃ©es -> vues) et un ViewHolder (recyclage des vues pour perf)."
            }
        ]
    }
]