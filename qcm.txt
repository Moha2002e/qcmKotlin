1. Concernant Intent, lesquelles sont vraies ? 
A. Un Intent explicite cible une classe précise 
B. Un Intent implicite nécessite toujours un ComponentName 
C. Les Intent implicites utilisent les IntentFilter 
D. Un Intent ne peut pas transporter d’objets complexes 
E. Un Intent peut être utilisé pour démarrer un service 
2. Quelle(s) a irmation(s) sur PendingIntent sont correctes ? 
A. Il permet à une application externe d’exécuter une action dans votre contexte 
B. Il est toujours lié à une Activity 
C. Il est requis pour les notifications 
D. Il remplace un Intent 
E. Il peut encapsuler un Broadcast 
4. Concernant le cycle de vie d’une Activity 
A. onCreate() est appelé une seule fois par instance 
B. onPause() garantit que l’activité est détruite 
C. onStop() signifie que l’UI n’est plus visible 
D. onRestart() est appelé après onCreate() 
E. onDestroy() peut ne jamais être appelé 
5. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
constantes Intent.ACTION_* en Android ? 
A. Elles représentent des actions standard reconnues par le système Android 
B. Elles sont principalement utilisées avec des Intents implicites 
C. Intent.ACTION_* permet de cibler directement une Activity précise 
D. Elles peuvent être associées à des IntentFilter dans le manifeste 
E. Elles remplacent l’utilisation des ComponentName 
6. À propos des Fragment 
A. Un fragment doit être attaché à une activité 
B. Un fragment possède son propre Context 
C. Un fragment a un cycle de vie distinct 
D. Les fragments sont dépréciés 
E. Un fragment peut survivre à une rotation 
7. Quelle méthode correspond à l’initialisation de la vue d’un fragment ? 
A. onAttach() 
B. onCreateView() 
C. onCreate() 
D. onViewCreated() 
E. onStart() 
8. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
expressions lambda en Kotlin ? 
A. Une lambda est une fonction anonyme 
B. Une lambda peut être passée comme paramètre à une fonction 
C. Une lambda ne peut pas capturer de variables externes 
D. Le type d’une lambda peut être inféré par le compilateur 
E. Une lambda ne peut pas retourner de valeur 
9. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
fonctions d’ordre supérieur en Kotlin ? 
A. Une fonction d’ordre supérieur peut prendre une ou plusieurs fonctions en paramètre 
B. Une fonction d’ordre supérieur peut retourner une fonction 
C. Une fonction d’ordre supérieur doit obligatoirement être inline 
D. Les fonctions d’ordre supérieur sont largement utilisées avec les lambdas 
E. Une fonction d’ordre supérieur ne peut pas être stockée dans une variable 
10. À propos de lateinit 
A. Uniquement pour les types non-null 
B. Ne fonctionne pas avec les types primitifs 
C. Peut être utilisé avec val 
D. Provoque une exception si non initialisé 
E. Compatible avec lazy 
11. Di érence entre lazy et lateinit 
A. lazy est thread-safe par défaut 
B. lazy est uniquement pour val 
C. lateinit ne supporte pas les primitives 
D. lateinit est évalué à l’accès 
E. lazy peut être réassigné 
12. À propos des coroutines 
A. Une coroutine n’est pas un thread 
B. Une coroutine peut être suspendue 
C. Une coroutine bloque toujours le thread 
D. suspend n’indique pas l’asynchronisme 
E. Une coroutine survit à la mort du process 
13. Que fait exactement suspend ? 
A. Rend la fonction asynchrone 
B. Crée un thread 
C. Permet la suspension sans bloquer 
D. Peut appeler d’autres fonctions suspendues 
E. Garantit un contexte IO 
14. Concernant runBlocking 
A. Bloque le thread courant 
B. À utiliser en production Android 
C. Utile pour les tests 
D. Remplace launch 
E. Fonctionne uniquement sur Main thread 
15. Quelle est la di érence entre launch et async ? 
A. launch retourne une valeur 
B. async retourne un Deferred 
C. async nécessite await() 
D. launch bloque 
E. async ne peut pas être annulé 
16. Concernant Dispatcher.Main 
A. Exécute sur le thread UI 
B. Peut être utilisé pour IO intensif 
C. Requiert Dispatchers.Main.immediate pour éviter un post 
D. Est toujours disponible 
E. Nécessite Android 
17. À propos de l’annulation (cancel) 
A. Elle est coopérative 
B. Elle stoppe immédiatement la coroutine 
C. Les suspending functions la respectent 
D. Elle tue le thread 
E. Elle propage aux enfants 
18. Quelle exception est levée lors d’une annulation ? 
A. TimeoutException 
B. IllegalStateException 
C. CancellationException 
D. IOException 
E. RuntimeException 
19. Quelle est la portée correcte pour une coroutine liée à un Fragment ? 
A. GlobalScope 
B. MainScope 
C. viewLifecycleOwner.lifecycleScope 
D. activityScope 
E. applicationScope 
20. Concernant RecyclerView 
A. Il recycle les ViewHolder 
B. Il est plus performant que ListView 
C. Il impose un layout vertical 
D. Il nécessite un Adapter 
E. Il gère automatiquement les clics 
21. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
fonctions de portée (let, run, apply, also, with) en Kotlin ? 
A. Les fonctions de portée permettent d’exécuter un bloc de code dans le contexte d’un objet 
B. Elles di èrent par la valeur de retour et la manière d’accéder au receiver (this ou it) 
C. Toutes les fonctions de portée retournent toujours l’objet receiver 
D. Elles améliorent la lisibilité et réduisent le code répétitif 
E. Les fonctions de portée remplacent les classes et les fonctions classiques 
22. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
fonctions de portée Kotlin (let, run, with, apply, also) ? 
A. let et also utilisent it comme contexte d’accès à l’objet 
B. apply et also retournent l’objet receiver 
C. run et with retournent le résultat du dernier bloc exécuté 
D. with peut être appelé sur un objet nullable sans vérification préalable 
E. apply est particulièrement adapté à la configuration ou au pattern builder 
23. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
propriétés isActive, isCancelled et isCompleted d’une coroutine (Job) ? 
A. isActive est vrai tant que la coroutine s’exécute ou peut encore s’exécuter 
B. isCancelled devient vrai lorsqu’une annulation est demandée, même si la coroutine n’est pas 
encore terminée 
C. isCompleted devient vrai uniquement lorsque la coroutine a terminé son exécution (succès 
ou échec) 
D. isCancelled et isCompleted sont toujours vrais simultanément 
E. Une coroutine annulée est considérée comme complétée (isCompleted == true) une fois son 
exécution terminée 
24. Concernant ViewBinding 
A. Généré à la compilation 
B. Utilise la réflexion 
C. Supprime findViewById 
D. Est plus lent que DataBinding 
E. Respecte le type-safety 
25. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant 
CoroutineContext, CoroutineDispatcher et CoroutineScope ? 
A. CoroutineContext est une collection d’éléments décrivant l’environnement d’exécution d’une 
coroutine 
B. CoroutineDispatcher détermine sur quel thread ou pool de threads la coroutine s’exécute 
C. CoroutineScope définit la durée de vie des coroutines qu’il lance 
D. CoroutineDispatcher est obligatoire pour lancer une coroutine 
E. Un CoroutineScope combine généralement un CoroutineContext et un Job 
26. Concernant Navigation Component 
A. Gère le back stack 
B. Remplace FragmentManager 
C. Utilise un NavGraph 
D. Fonctionne sans fragments 
E. Facilite SafeArgs 
27. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant une 
suspending function en Kotlin ? 
A. Une suspending function peut suspendre son exécution sans bloquer le thread 
B. Une suspending function ne peut être appelée que depuis une coroutine ou une autre 
suspending function 
C. Une suspending function crée automatiquement un nouveau thread 
D. Lorsqu’elle est suspendue, le thread peut exécuter d’autres tâches 
E. Une suspending function garantit une exécution parallèle 
28. Quelle classe gère la navigation ? 
A. FragmentManager 
B. NavController 
C. NavHost 
D. Router 
E. ActivityManager 
29. Quelle est la responsabilité de NavHostFragment ? 
A. Gérer les intents 
B. A icher les destinations 
C. Créer les fragments 
D. Sauvegarder l’état 
E. Gérer ViewBinding 
30. Concernant Kotlin null-safety 
A. ? rend nullable 
B. !! peut lever une exception 
C. ?: est un opérateur Elvis 
D. let évite les NPE 
E. lateinit accepte null 
31. Quel(s) scope(s) Kotlin existent ? 
A. let 
B. apply 
C. run 
D. with 
E. also 
32. Di érence entre apply et also 
A. apply retourne le receiver 
B. also retourne le receiver 
C. apply utilise this 
D. also utilise it 
E. also modifie le receiver 
33. Concernant sealed class 
A. Restreint l’héritage 
B. Peut être étendue partout 
C. Utile pour when exhaustif 
D. Remplacée par enum 
E. Permet des états complexes 
34. À propos de when 
A. Peut être exhaustif 
B. Remplace if uniquement 
C. Fonctionne avec sealed class 
D. Est une expression 
E. Ne retourne rien 
36. Quelle a irmation est vraie sur inline ? 
A. Réduit l’overhead lambda 
B. Augmente la taille du bytecode 
C. Utilisable avec reified 
D. Obligatoire 
E. Désactivée sur Android 
38. Concernant les data class 
A. Génèrent equals/hashCode 
B. Génèrent copy() 
C. Peuvent être abstract 
D. Peuvent être sealed 
E. Améliorent l’immuabilité 
40. Quelle(s) bonne(s) pratique(s) Android/Kotlin ? 
A. Éviter GlobalScope 
B. Utiliser lifecycleScope 
C. Bloquer le thread Main 
D. Préférer immutabilité 
E. Limiter les context leaks 
41. Concernant lifecycleScope 
A. Disponible uniquement dans les fragments 
B. Annule automatiquement les coroutines à la destruction 
C. Basé sur le LifecycleOwner 
D. Exécute toujours sur Dispatchers.IO 
E. Évite les memory leaks 
42. Di érence entre lifecycleScope et viewLifecycleOwner.lifecycleScope 
A. Ils sont identiques 
B. Le second est lié au cycle de vie de la vue 
C. Évite les crashes après onDestroyView() 
D. Le premier est déprécié 
E. Le second fonctionne dans une Activity 
43. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
suspending functions et le mécanisme de Continuation<T> en Kotlin ? 
A. Une suspending function est compilée avec un paramètre implicite de type Continuation<T> 
B. Continuation<T> représente la suite de l’exécution après un point de suspension 
C. Une suspending function crée systématiquement un nouveau thread 
D. Le compilateur transforme une suspending function en machine à états 
E. La suspension permet de libérer le thread sans consommer de ressources importantes 
44. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant 
l’internationalisation (i18n) et l’utilisation des fichiers de ressources dans Android ? 
A. Les chaînes traduites sont définies dans des fichiers strings.xml spécifiques par langue 
B. Android sélectionne automatiquement les ressources en fonction de la locale du système 
C. Les fichiers de ressources internationalisées doivent être chargés manuellement dans le 
code 
D. Il est possible de définir des variantes régionales (ex. fr-rBE, en-rUS) 
E. L’internationalisation empêche toute modification dynamique de la langue de l’application 
45. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant 
Configuration, l’accès via getConfiguration() et l’utilisation de Locale en Android ? 
A. getConfiguration() permet d’accéder à la configuration courante de l’appareil (langue, 
orientation, densité, etc.) 
B. La langue courante peut être obtenue à partir de Configuration.locale ou 
Configuration.locales selon la version d’Android 
C. Modifier un objet Locale met automatiquement à jour la langue de l’application 
D. À partir d’Android 7.0, plusieurs locales peuvent être définies via LocaleList 
E. Un changement de Configuration peut déclencher la recréation d’une Activity 
46. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant 
l’architecture Android et les rôles respectifs des Libraries, de la HAL (Hardware Abstraction 
Layer) et du hardware ? 
A. La HAL fournit une interface standardisée entre le framework Android et le matériel 
B. Les Libraries Android o rent des fonctionnalités de haut niveau accessibles aux applications 
C. Le hardware est directement manipulé par les applications Android 
D. La HAL permet d’isoler Android des spécificités matérielles des constructeurs 
E. Les Libraries remplacent la HAL pour l’accès aux composants matériels 
47. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant la 
machine virtuelle Dalvik dans l’écosystème Android ? 
A. Dalvik est une machine virtuelle conçue spécifiquement pour les appareils mobiles Android 
B. Dalvik exécute des fichiers au format .dex (Dalvik Executable) 
C. Dalvik utilise exclusivement la compilation AOT (Ahead-Of-Time) 
D. Dalvik a été remplacée progressivement par ART à partir d’Android 5.0 
E. Dalvik fonctionne avec un modèle “une VM par application” afin d’isoler les apps 
48. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
densités d’écran (ldpi, mdpi, hdpi) et la gestion des ressources Android ? 
A. mdpi est considérée comme la densité de référence (baseline) 
B. Android sélectionne automatiquement les ressources graphiques adaptées à la densité de 
l’écran 
C. ldpi correspond à une densité plus élevée que hdpi 
D. Les ressources peuvent être placées dans des dossiers spécifiques comme drawable-ldpi, 
drawable-mdpi, drawable-hdpi 
E. Fournir une ressource uniquement en hdpi empêche son a ichage sur un écran mdpi 
49. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
Services Android et l’utilisation de startService / arrêt d’un service ? 
A. Un service démarré avec startService peut continuer à s’exécuter même si l’Activity 
appelante est détruite 
B. Un service démarré doit être arrêté explicitement via stopService ou stopSelf 
C. Un service démarre toujours sur un thread séparé 
D. Le système Android peut arrêter un service pour récupérer des ressources 
E. Un service démarré ne peut pas être redémarré après avoir été arrêté 
50. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
méthodes onCreate, onDestroy et onBind d’un Service Android ? 
A. onCreate est appelée une seule fois lors de la création du service 
B. onDestroy est appelée lorsque le service est définitivement arrêté 
C. onBind est appelée lorsqu’un composant se lie au service 
D. onBind est appelée pour un service démarré uniquement avec startService 
E. Un service lié utilise onBind pour exposer une interface de communication aux clients 
51. À propos de SavedStateHandle 
A. Persiste après process death 
B. Remplace ViewModel 
C. Fonctionne avec Navigation 
D. Sauvegarde automatiquement tout 
E. Accessible dans ViewModel 
52. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
Fragments et les Activities en Android ? 
A. Une Activity représente un écran complet et constitue un point d’entrée de l’application 
B. Un Fragment est toujours hébergé par une Activity 
C. Un Fragment peut exister indépendamment d’une Activity 
D. Les Fragments permettent une UI plus modulaire et réutilisable 
E. Une Activity partage automatiquement son cycle de vie avec tous ses Fragments 
58. ConstraintLayout 
A. Réduit la hiérarchie 
B. Plus lent que LinearLayout 
C. Supporte les chaînes 
D. Oblige XML complexe 
E. Déprécié 
59. Concernant la navigation back 
A. NavController gère le back stack 
B. FragmentManager est obligatoire 
C. PopBackStack possible 
D. Le système ignore le graphe 
E. Back est automatique partout 
65. Concernant coroutineScope 
A. Attend toutes les coroutines enfants 
B. Lance des GlobalScope 
C. Propague les exceptions 
D. Bloque le thread 
E. Remplace supervisorScope 
67. Concernant ExceptionHandler 
A. Intercepte les exceptions non catchées 
B. Remplace try/catch 
C. Appliqué au scope 
D. Fonctionne avec async 
E. Stoppe le thread 
68. Kotlin Result<T> 
A. Encapsule succès/échec 
B. Remplace exceptions 
C. Immuable 
D. Toujours recommandé 
E. Bloque la stacktrace 
70. Concernant Context 
A. Activity est un Context 
B. ApplicationContext survit toujours 
C. Context peut causer des leaks 
D. Context = View 
E. Ne pas stocker Activity 
73. Concernant les lambdas 
A. Fonctions anonymes 
B. Toujours inline 
C. Supportent capture 
D. Pas de retour 
E. Bloquantes 
74. Kotlin immutabilité 
A. val préféré 
B. var interdit 
C. Favorise thread-safety 
D. Inutile en Android 
E. Réduit bugs 
75. Considère le code Kotlin suivant : 
val a = 10 
var b = a 
val c: Number = a 
var d: Int? = null 
Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) ? 
A. a est une constante et ne peut jamais être modifiée 
B. b peut être réassignée car son type est inféré comme Int 
C. c ne peut pas être réassignée car son type explicite est Number 
D. d ne peut accepter que null ou des Int 
E. Le typage explicite empêche toute inférence du compilateur 
76. Considère les instructions Kotlin suivantes : 
for (i in 1..5) print(i) 
for (i in 0 until 5) print(i) 
for (i in 10 downTo 0 step 2) print(i) 
Quelle(s) a irmation(s) est/sont correcte(s) ? 
A. L’opérateur .. inclut la borne supérieure 
B. until exclut la borne supérieure 
C. downTo permet une itération décroissante 
D. step modifie la valeur finale de la borne 
E. step définit l’incrément (ou décrément) entre deux valeurs successives 
77. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant les 
mots-clés open et final en Kotlin ? 
A. En Kotlin, les classes sont final par défaut 
B. Une classe marquée open peut être héritée 
C. Une fonction doit être open pour pouvoir être appelée 
D. Une fonction open peut être redéfinie (override) dans une sous-classe 
E. Le mot-clé final empêche l’héritage ou la redéfinition 
78. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant 
ViewBinding et findViewById ? 
A. ViewBinding fournit un accès type-safe aux vues 
B. ViewBinding élimine le besoin d’appeler findViewById 
C. findViewById est vérifié à la compilation 
D. ViewBinding réduit le risque de NullPointerException 
E. ViewBinding repose sur la réflexion à l’exécution 
79. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant 
l’utilisation de startActivity dans une application Android ? 
A. startActivity permet de lancer une nouvelle Activity via un Intent 
B. Un Context valide est requis pour appeler startActivity 
C. startActivity permet de récupérer directement un résultat 
D. startActivity peut être utilisé avec un Intent explicite ou implicite 
E. startActivity gère automatiquement le cycle de vie de l’Activity appelante 
80. Laquelle (ou lesquelles) des a irmations suivantes est/sont correcte(s) concernant 
l’utilisation de putExtra et des méthodes getXXXExtra dans les Intent Android ? 
A. putExtra permet d’ajouter des données supplémentaires à un Intent 
B. getXXXExtra doit correspondre au type exact de la donnée stockée 
C. Un Intent ne peut contenir qu’un seul extra 
D. Les extras sont stockés sous forme de paires clé/valeur 
E. getXXXExtra lève systématiquement une exception si la clé n’existe pas 
Termes :  
Définissables en 2–3 lignes maximum. 
1. Intent explicite 
2. Intent implicite 
3. ViewBinding 
4. Fragment 
5. Activity 
6. CoroutineScope 
7. CoroutineDispatcher 
8. Suspending function 
9. Continuation 
10. LifecycleScope 
11. Service Android 
12. Lambdas 
13. HAL (Hardware Abstraction Layer) 
14. Fonction d’extensions 
15. Fonctions d’ordre supérieure